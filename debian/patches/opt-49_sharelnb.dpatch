#! /bin/sh /usr/share/dpatch/dpatch-run
## opt-31_sharelnb.dpatch by Matthias Lötzke <Matthias@Loetzke.de>
## http://www.xn--ltzke-jua.de/dvb/VDR_LNB_sharing_patch/configurableLNBshare-VDR_1.4.3.patch
##
## All lines beginning with `## DP:' are a description of the patch.
## DP: Patch to share one sat connection for several cards.

@DPATCH@
diff -urNad vdr-1.4.4~/config.c vdr-1.4.4/config.c
--- vdr-1.4.4~/config.c	2006-11-04 19:42:37.000000000 +0100
+++ vdr-1.4.4/config.c	2006-11-04 19:42:37.000000000 +0100
@@ -324,6 +324,12 @@
   CurrentDolby = 0;
   InitialChannel = 0;
   InitialVolume = -1;
+
+//ML
+  VerboseLNBlog = 0;
+  for (int i = 0; i < MAXDEVICES; i++) CardUsesLNBnr[i] = i + 1;
+//ML-Ende
+ 
   ShowRecDate = 1;
   ShowRecTime = 1;
   ShowRecLength = 0;
@@ -559,7 +565,23 @@
   else if (!strcasecmp(Name, "DvdTrayMode"))         DvdTrayMode        = atoi(Value);
   else if (!strcasecmp(Name, "DvdSpeedLimit"))       DvdSpeedLimit      = atoi(Value);
   else
-     return false;
+
+//ML
+  if (!strcasecmp(Name, "VerboseLNBlog")) VerboseLNBlog = atoi(Value);
+  else {
+    char tmp[20];
+    bool result = false;
+    for (int i = 1; i <= MAXDEVICES; i++) {
+      sprintf(tmp, "Card%dusesLNBnr", i);
+      if (!strcasecmp(Name, tmp)) {
+        CardUsesLNBnr[i - 1] = atoi(Value);
+        result = true;
+      }
+    }  
+     return result;
+  }
+//ML-Ende
+
   return true;
 }
 
@@ -648,6 +670,17 @@
   Store("DvdTrayMode",        DvdTrayMode);
   Store("DvdSpeedLimit",      DvdSpeedLimit);
 
+//ML
+  Store("VerboseLNBlog",       VerboseLNBlog);
+  char tmp[20];
+  if (cDevice::NumDevices() > 1) {
+     for (int i = 1; i <= cDevice::NumDevices(); i++) {
+        sprintf(tmp, "Card%dusesLNBnr", i);
+        Store(tmp, CardUsesLNBnr[i - 1]);
+     }
+  }
+//ML-Ende
+
   Sort();
 
   if (cConfig<cSetupLine>::Save()) {
diff -urNad vdr-1.4.4~/config.h vdr-1.4.4/config.h
--- vdr-1.4.4~/config.h	2006-11-04 19:42:37.000000000 +0100
+++ vdr-1.4.4/config.h	2006-11-04 19:42:37.000000000 +0100
@@ -294,6 +294,15 @@
   int DvdSpeedLimit;
   int InitialChannel;
   int InitialVolume;
+
+//ML
+  int VerboseLNBlog;
+  #define MAXDEVICES 16 // Since VDR 1.3.32 we can not #include "device.h" for MAXDEVICES anymore. 
+                        // With this workaround a warning will be shown during compilation if 
+                        // MAXDEVICES changes in device.h.
+  int CardUsesLNBnr[MAXDEVICES];
+//ML-Ende
+
   int ShowRecDate, ShowRecTime, ShowRecLength, ShowProgressBar, MenuCmdPosition;
   int __EndData__;
   cSetup(void);
diff -urNad vdr-1.4.4~/device.c vdr-1.4.4/device.c
--- vdr-1.4.4~/device.c	2006-11-04 19:42:37.000000000 +0100
+++ vdr-1.4.4/device.c	2006-11-04 19:42:37.000000000 +0100
@@ -19,6 +19,10 @@
 #include "status.h"
 #include "transfer.h"
 
+//ML
+#include "diseqc.h"
+//ML-Ende
+
 // --- cPesAssembler ---------------------------------------------------------
 
 class cPesAssembler {
@@ -155,6 +159,12 @@
 
   SetVideoFormat(Setup.VideoFormat);
 
+//ML
+  LNBstate = -1;
+  LNBnr = Setup.CardUsesLNBnr[cardIndex];
+  LNBsource = NULL;
+//ML-Ende
+
   mute = false;
   volume = Setup.CurrentVolume;
 
@@ -216,6 +226,16 @@
      useDevice |= (1 << n);
 }
 
+//ML
+void cDevice::SetLNBnr(void)
+{
+  for (int i = 0; i < numDevices; i++) {
+    device[i]->LNBnr = Setup.CardUsesLNBnr[i];
+    isyslog("LNB-sharing: setting device %d to use LNB %d", i, device[i]->LNBnr);
+  }
+}
+//ML-Ende
+
 int cDevice::NextCardIndex(int n)
 {
   if (n > 0) {
@@ -275,6 +295,98 @@
   return d;
 }
 
+//ML
+cDevice *cDevice::GetBadDevice(const cChannel *Channel)
+{
+  if(!cSource::IsSat(Channel->Source())) return NULL;
+  if (Setup.DiSEqC) {
+    cDiseqc *diseqc;
+    diseqc = Diseqcs.Get(Channel->Source(), Channel->Frequency(), Channel->Polarization());
+
+    for (int i = 0; i < numDevices; i++) {
+      if (this != device[i] && device[i]->GetLNBnr() == LNBnr && device[i]->GetLNBsource() != (int*) diseqc) {
+        if (Setup.VerboseLNBlog) {
+          isyslog("LNB %d: Device check for channel %d on device %d. LNB or DiSEq conflict with device %d", LNBnr, Channel->Number(), this->DeviceNumber(), i);
+        }
+        return device[i];
+      }
+    }
+    if (Setup.VerboseLNBlog) { 
+      isyslog("LNB %d: Device check for for channel %d on device %d. OK", LNBnr, Channel->Number(), this->DeviceNumber());
+    }
+  } else {
+    char requiredState;
+    if (Channel->Frequency() >= Setup.LnbSLOF) {
+      requiredState = 1 ;
+    } else {
+      requiredState = 0;
+    }
+    if (Channel->Polarization() == 'v' || Channel->Polarization() == 'V') requiredState += 2;
+
+    for (int i = 0; i < numDevices; i++) {
+      if (this != device[i] && device[i]->GetLNBnr() == LNBnr && device[i]->GetLNBconf() != requiredState) {
+        if (Setup.VerboseLNBlog) {
+          isyslog("LNB %d: Device check for channel %d, LNBstate %d on device %d, current LNBstate %d. Conflict with device %d, LNBstate %d", LNBnr, Channel->Number(), requiredState, this->DeviceNumber(), LNBstate, i, device[i]->GetLNBconf());
+        }
+        return device[i];
+      }
+    }
+    if (Setup.VerboseLNBlog) { 
+      isyslog("LNB %d: Device check for channel %d, LNBstate %d on device %d, current LNBstate %d. No other devices affected", LNBnr, Channel->Number(), requiredState, this->DeviceNumber(), LNBstate);
+    }
+  }
+  return NULL;
+}
+
+int cDevice::GetMaxBadPriority(const cChannel *Channel)
+{                                
+  if(!cSource::IsSat(Channel->Source())) return -2;
+  bool PrimaryIsBad = false;
+  int maxBadPriority = -2;
+  if (Setup.DiSEqC) {
+    cDiseqc *diseqc;
+    diseqc = Diseqcs.Get(Channel->Source(), Channel->Frequency(), Channel->Polarization());
+
+    for (int i = 0; i < numDevices; i++) {
+      if (this != device[i] && device[i]->GetLNBnr() == LNBnr && device[i]->GetLNBsource() != (int*) diseqc) {
+        if (device[i]->Receiving() && device[i]->Priority() > maxBadPriority) {
+          maxBadPriority = device[i]->Priority();
+        }
+        if (device[i]->IsPrimaryDevice()) {
+            PrimaryIsBad = true;
+        }
+      }
+    }
+  } else {
+    char requiredState;
+    if (Channel->Frequency() >= Setup.LnbSLOF) {
+      requiredState = 1 ;
+    } else {
+      requiredState = 0;
+    }
+    if (Channel->Polarization() == 'v' || Channel->Polarization() == 'V') requiredState += 2;
+
+    for (int i = 0; i < numDevices; i++) {
+      if (this != device[i] && device[i]->GetLNBnr() == LNBnr && device[i]->GetLNBconf() != requiredState) {
+        if (device[i]->Receiving() && device[i]->Priority() > maxBadPriority) {
+          maxBadPriority = device[i]->Priority();
+        }
+        if (device[i]->IsPrimaryDevice()) {
+            PrimaryIsBad = true;
+        }
+      }
+    }
+  }
+  if (PrimaryIsBad && maxBadPriority == -2) {
+    maxBadPriority = -1;
+  }
+  if (Setup.VerboseLNBlog) { 
+    isyslog("LNB %d: Request for channel %d on device %d. MaxBadPriority is %d", LNBnr, Channel->Number(), this->DeviceNumber(), maxBadPriority);
+  }
+  return maxBadPriority;
+}
+//ML-Ende
+
 cDevice *cDevice::GetDevice(int Index)
 {
   return (0 <= Index && Index < numDevices) ? device[Index] : NULL;
@@ -284,6 +396,12 @@
 {
   cDevice *d = NULL;
   uint Impact = 0xFFFFFFFF; // we're looking for a device with the least impact
+
+//ML
+  int badPriority;
+  uint imp2;
+//ML-Ende
+
   for (int i = 0; i < numDevices; i++) {
       bool ndr;
       if (device[i]->ProvidesChannel(Channel, Priority, &ndr)) { // this device is basicly able to do the job
@@ -301,7 +419,30 @@
          imp <<= 8; imp |= min(max(device[i]->ProvidesCa(Channel), 0), 0xFF);      // use the device that provides the lowest number of conditional access methods
          imp <<= 1; imp |= device[i]->IsPrimaryDevice();                           // avoid the primary device
          imp <<= 1; imp |= device[i]->HasDecoder();                                // avoid full featured cards
-         if (imp < Impact) {
+
+//ML
+         badPriority = device[i]->GetMaxBadPriority(Channel);
+         if (badPriority >= Priority || (badPriority == -1 && Priority < Setup.PrimaryLimit)) {
+            // channel is not available for the requested prioity
+            imp = 0xFFFFFFFF;
+         } else {
+            switch (badPriority) {
+               case -2: // not affected by LNB-sharing
+                  imp2 = 0;
+                  break;
+               case -1: // the primary device would need a channel switch
+				  imp += 1 <<  17;
+                  imp2 = 0xFFFFFFFF | 1 << 17;
+                  break;
+               default: // a device receiving with lower priority would need to be stopped
+                  imp += badPriority << 8;
+                  imp2 = 0xFFFFFFFF | badPriority << 8;
+                  break;
+            }
+         }
+         if (imp < Impact && imp2 < Impact) {
+//ML-Ende
+
             // This device has less impact than any previous one, so we take it.
             Impact = imp;
             d = device[i];
@@ -547,7 +688,11 @@
 bool cDevice::ProvidesTransponderExclusively(const cChannel *Channel) const
 {
   for (int i = 0; i < numDevices; i++) {
-      if (device[i] && device[i] != this && device[i]->ProvidesTransponder(Channel))
+
+//ML
+      if (device[i] && device[i] != this && device[i]->ProvidesTransponder(Channel) && device[i]->GetLNBnr() != LNBnr)
+//ML-Ende
+
          return false;
       }
   return true;
@@ -570,6 +715,26 @@
 
 bool cDevice::SwitchChannel(const cChannel *Channel, bool LiveView)
 {
+
+//ML
+  cDevice *tmpDevice;
+	if (this->GetMaxBadPriority(Channel) >= 0) {
+		Skins.Message(mtInfo, tr("Channel locked by LNB!"));
+		return false;
+	}
+	while ((tmpDevice = GetBadDevice(Channel)) != NULL) {
+		if (tmpDevice->IsPrimaryDevice() && LiveView)
+			tmpDevice->SwitchChannelForced(Channel, true);
+		else
+			tmpDevice->SwitchChannelForced(Channel, false);
+   	}
+    return SwitchChannelForced(Channel, LiveView);
+}
+
+bool cDevice::SwitchChannelForced(const cChannel *Channel, bool LiveView)
+//ML-Ende
+
+{
   if (LiveView)
      isyslog("switching to channel %d", Channel->Number());
   for (int i = 3; i--;) {
@@ -598,10 +763,13 @@
      {
            // try only channels which are currently available
         if (cStatus::MsgChannelProtected(0, channel) == false)      // PIN PATCH
-           if (PrimaryDevice()->ProvidesChannel(channel, Setup.PrimaryLimit) || PrimaryDevice()->CanReplay() && GetDevice(channel, 0))
-              break;
-           n = channel->Number() + Direction;
-           }
+
+//ML
+	    if (PrimaryDevice()->GetMaxBadPriority(channel) < 0 && (PrimaryDevice()->ProvidesChannel(channel, Setup.PrimaryLimit) || PrimaryDevice()->CanReplay() && GetDevice(channel, 0)))       
+//ML-Ende
+
+	n = channel->Number() + Direction;
+     }
      if (channel) {
         int d = n - first;
         if (abs(d) == 1)
@@ -638,12 +806,40 @@
 
   eSetChannelResult Result = scrOk;
 
+//ML
+  char requiredState;
+  if (Channel->Frequency() >= Setup.LnbSLOF) {
+    requiredState = 1;
+  } else {
+    requiredState = 0;
+  }
+  if (Channel->Polarization() == 'v' || Channel->Polarization() == 'V') requiredState += 2;
+  if (Setup.VerboseLNBlog) {
+    isyslog("LNB %d: Switching device %d to channel %d", LNBnr, this->DeviceNumber(), Channel->Number());
+  }
+//ML-Ende
+
   // If this DVB card can't receive this channel, let's see if we can
   // use the card that actually can receive it and transfer data from there:
 
   if (NeedsTransferMode) {
      cDevice *CaDevice = GetDevice(Channel, 0, &NeedsDetachReceivers);
      if (CaDevice && CanReplay()) {
+
+//ML
+       if (CaDevice->GetLNBnr() == LNBnr) {
+         if (LNBstate != requiredState || (Setup.DiSEqC && LNBsource != (int*) Diseqcs.Get(Channel->Source(), Channel->Frequency(), Channel->Polarization())) ) {
+           if (IsPrimaryDevice()) {
+             SetChannelDevice(Channel, true);
+           } else {
+             SetChannelDevice(Channel, false);
+           }
+         LNBstate = requiredState;
+         LNBsource = (int*) Diseqcs.Get(Channel->Source(), Channel->Frequency(), Channel->Polarization());
+         }
+       }
+//ML-Ende
+
         cStatus::MsgChannelSwitch(this, 0); // only report status if we are actually going to switch the channel
         if (CaDevice->SetChannel(Channel, false) == scrOk) { // calling SetChannel() directly, not SwitchChannel()!
            if (NeedsDetachReceivers)
@@ -664,6 +860,12 @@
         sectionHandler->SetStatus(false);
         sectionHandler->SetChannel(NULL);
         }
+
+//ML
+     LNBstate = requiredState;
+     LNBsource = (int*) Diseqcs.Get(Channel->Source(), Channel->Frequency(), Channel->Polarization());
+//ML-Ende
+
      // Tell the ciHandler about the channel switch and add all PIDs of this
      // channel to it, for possible later decryption:
      if (ciHandler) {
diff -urNad vdr-1.4.4~/device.h vdr-1.4.4/device.h
--- vdr-1.4.4~/device.h	2006-11-04 19:42:37.000000000 +0100
+++ vdr-1.4.4/device.h	2006-11-04 19:44:36.000000000 +0100
@@ -230,6 +230,13 @@
   bool SwitchChannel(const cChannel *Channel, bool LiveView);
          ///< Switches the device to the given Channel, initiating transfer mode
          ///< if necessary.
+
+//ML
+  bool SwitchChannelForced(const cChannel *Channel, bool LiveView);
+         ///< Switches the device to the given channel, initiating transfer mode
+         ///< if necessary. Forces the switch without taking care of the LNB configuration.
+//ML-Ende
+
   static bool SwitchChannel(int Direction);
          ///< Switches the primary device to the next available channel in the given
          ///< Direction (only the sign of Direction is evaluated, positive values
@@ -546,6 +553,32 @@
        ///< Detaches all receivers from this device for this pid.
   void DetachAllReceivers(void);
        ///< Detaches all receivers from this device.
+
+//ML
+private:
+  char LNBstate;  // Current frequency band and polarization of the DVB-tuner
+//  cDiseqc *LNBsource;  // can not #include "diseqc.h". A workaround follows:
+  int *LNBsource;  // [DiSEqC] DiSEqC-Source
+  int LNBnr;      // Number of LNB used
+public:
+  char GetLNBconf(void) { return LNBstate; }
+  int *GetLNBsource(void) { return LNBsource; }
+  int GetLNBnr(void) { return LNBnr; }
+  static void SetLNBnr(void);
+  cDevice *GetBadDevice(const cChannel *Channel);
+         ///< Returns NULL if there is no device which uses the same LNB or if
+         ///< all of those devices are tuned to the same frequency band and 
+         ///< polarization as of the requested channel.
+         ///< Otherwise returns the first device found.
+  int GetMaxBadPriority(const cChannel *Channel);
+         ///< Returns the highest priority of all receiving devices which use
+         ///< the same LNB and are tuned to a different frequency band or 
+         ///< polarization as of the requested channel.
+         ///< Returns -1 if there are no such devices, but the primary device 
+         ///< would be affected by switching to the requested channel.
+         ///< Returns -2 if there are no such devices and the primary device 
+         ///< would not be affected by switching to the requested channel.
+//ML-Ende
   };
 
 /// Derived cDevice classes that can receive channels will have to provide
diff -urNad vdr-1.4.4~/eitscan.c vdr-1.4.4/eitscan.c
--- vdr-1.4.4~/eitscan.c	2006-01-07 15:10:17.000000000 +0100
+++ vdr-1.4.4/eitscan.c	2006-11-04 19:42:37.000000000 +0100
@@ -151,9 +151,11 @@
                             if (Device->ProvidesTransponder(Channel)) {
                                if (!Device->Receiving()) {
                                   bool MaySwitchTransponder = Device->MaySwitchTransponder();
-                                  if (MaySwitchTransponder || Device->ProvidesTransponderExclusively(Channel) && now - lastActivity > Setup.EPGScanTimeout * 3600) {
+//ML
+                                  if (MaySwitchTransponder && Device->GetMaxBadPriority(Channel) == -2 || Device->ProvidesTransponderExclusively(Channel) && Device->GetMaxBadPriority(Channel) <= -1 && now - lastActivity > Setup.EPGScanTimeout * 3600) {
                                      if (!MaySwitchTransponder) {
-                                        if (Device == cDevice::ActualDevice() && !currentChannel) {
+                                        if ((Device == cDevice::ActualDevice() || Device->GetMaxBadPriority(Channel) == -1) && !currentChannel) {
+//ML-Ende
                                            cDevice::PrimaryDevice()->StopReplay(); // stop transfer mode
                                            currentChannel = Device->CurrentChannel();
                                            Skins.Message(mtInfo, tr("Starting EPG scan"));
diff -urNad vdr-1.4.4~/i18n.c vdr-1.4.4/i18n.c
--- vdr-1.4.4~/i18n.c	2006-11-04 19:42:37.000000000 +0100
+++ vdr-1.4.4/i18n.c	2006-11-04 19:42:37.000000000 +0100
@@ -7122,6 +7122,76 @@
     "",//TODO
     "",//TODO
   },
+
+//ML
+  { "Channel locked by LNB!",
+    "Kanal durch LNB gesperrt!",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "Chaîne interdite par la LNB",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Setup.LNB$DVB device %d uses LNB No.",
+    "DVB-Empfänger %d nutzt LNB Nr.",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "La carte DVB %d utilise la LNB No.",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+  { "Setup.LNB$Log LNB usage",
+    "LNB-Nutzung protokollieren",
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+    "",// TODO
+  },
+//ML
+
   { NULL }
   };
 
diff -urNad vdr-1.4.4~/menu.c vdr-1.4.4/menu.c
--- vdr-1.4.4~/menu.c	2006-11-04 19:42:37.000000000 +0100
+++ vdr-1.4.4/menu.c	2006-11-04 19:42:37.000000000 +0100
@@ -2861,6 +2861,23 @@
 
   Clear();
 
+//ML
+  int numSatDevices = 0;
+  for (int i = 0; i < cDevice::NumDevices(); i++) {
+     	if (cDevice::GetDevice(i)->ProvidesSource(cSource::stSat)) numSatDevices++;
+  }     		
+  if (numSatDevices > 1) {
+  	 char tmp[30];
+     for (int i = 1; i <= cDevice::NumDevices(); i++) {
+     	if (cDevice::GetDevice(i - 1)->ProvidesSource(cSource::stSat)) {
+        	sprintf( tmp, tr("Setup.LNB$DVB device %d uses LNB No."), i);
+        	Add(new cMenuEditIntItem( tmp, &data.CardUsesLNBnr[i - 1], 1, numSatDevices ));
+        }
+     }
+   }
+  Add(new cMenuEditBoolItem(tr("Setup.LNB$Log LNB usage"), &data.VerboseLNBlog));
+//ML-Ende
+
   Add(new cMenuEditBoolItem(tr("Setup.LNB$Use DiSEqC"),               &data.DiSEqC));
   if (!data.DiSEqC) {
      Add(new cMenuEditIntItem( tr("Setup.LNB$SLOF (MHz)"),               &data.LnbSLOF));
@@ -2877,6 +2894,10 @@
   int oldDiSEqC = data.DiSEqC;
   eOSState state = cMenuSetupBase::ProcessKey(Key);
 
+//ML
+  if (Key == kOk) cDevice::SetLNBnr();
+//ML-Ende
+
   if (Key != kNone && data.DiSEqC != oldDiSEqC)
      Setup();
   return state;
@@ -3727,7 +3748,10 @@
      while (Channel) {
            Channel = Direction > 0 ? Channels.Next(Channel) : Channels.Prev(Channel);
 	if (cStatus::MsgChannelProtected(0, Channel) == false)                     // PIN PATCH
-           if (Channel && !Channel->GroupSep() && (cDevice::PrimaryDevice()->ProvidesChannel(Channel, Setup.PrimaryLimit) || cDevice::GetDevice(Channel, 0)))
+
+//ML
+           if (Channel && !Channel->GroupSep() && ((cDevice::PrimaryDevice()->ProvidesChannel(Channel, Setup.PrimaryLimit) && cDevice::PrimaryDevice()->GetMaxBadPriority(Channel) < 0) || cDevice::GetDevice(Channel, 0) ) )
+//ML-Ende
               return Channel;
            }
      }
@@ -4253,6 +4277,21 @@
      int Priority = Timer ? Timer->Priority() : Pause ? Setup.PausePriority : Setup.DefaultPriority;
      cDevice *device = cDevice::GetDevice(channel, Priority, &NeedsDetachReceivers);
      if (device) {
+
+//ML
+       cDevice *tmpDevice;
+       while ((tmpDevice = device->GetBadDevice(channel))) {
+         if (tmpDevice->Replaying() == false) {
+           Stop(tmpDevice);
+           if (tmpDevice->IsPrimaryDevice() )
+             tmpDevice->SwitchChannelForced(channel, true);
+           else
+             tmpDevice->SwitchChannelForced(channel, false);
+         } else
+		 tmpDevice->SwitchChannelForced(channel, false);
+	   }
+//ML-Ende
+
         if (NeedsDetachReceivers) {
            Stop(device);
            if (device == cTransferControl::ReceiverDevice())
